Module MazeInfo
    Sub InitialiseScreen()
        Console.BackgroundColor = ConsoleColor.Black
        Console.Clear()
        Console.ForegroundColor = ConsoleColor.White
    End Sub
    Sub RecrusiveBacktrackerInfo()
        Console.WriteLine("Steps in generating a maze using the recursive backtracker algorithm:")
        Console.WriteLine("     1. Choose a random starting cell from the grid, this becomes the current cell")
        Console.WriteLine("     2. Randomly carve a passage to an adjacent cell, but only if it hasn't already been visited")
        Console.WriteLine("     3. This cell now becomes the current cell")
        Console.WriteLine("     4. If there are no unvisited adjacent cells then go back on the path until an unvisited adjacent cell is found")
        Console.WriteLine("     5. The algorithm ends when there are no more unvisited cells on the grid")
        Console.WriteLine($"{Environment.NewLine}Recursive Backtracker algorithm:")
        Console.WriteLine("     1. Pick a random starting cell from the grid, make that the current cell and mark it as visited")
        Console.WriteLine("     2. While there are unvisited cells")
        Console.WriteLine("         1. If the current cell has unvisited neighbours")
        Console.WriteLine("             1. Randomly choose one of the unvisited neighbours")
        Console.WriteLine("             2. Carve a path to the unvisited neighbour from the current cell")
        Console.WriteLine("             3. The chosen neighbour now becomes the current cell")
        Console.WriteLine("             4. Push the current cell to the stack")
        Console.WriteLine("             5. Mark the current cell as visited")
        Console.WriteLine("         2. If the stack isn't empty")
        Console.WriteLine("             1. Pop a cell from the stack")
        Console.WriteLine("             2. Make it the current cell")
    End Sub
    Sub RecrusiveBacktrackerNotStackInfo()
        Console.WriteLine("This implementation uses a dictionary instead of a stack to keep track of where the cell came from")
        Console.WriteLine()
        Console.WriteLine("Steps in generating a maze using the recursive backtracker algorithm:")
        Console.WriteLine("     1. Choose a random starting cell from the grid, this becomes the current cell")
        Console.WriteLine("     2. Randomly carve a passage to an adjacent cell, but only if it hasn't already been visited")
        Console.WriteLine("     3. This cell now becomes the current cell")
        Console.WriteLine("     4. If there are no unvisited adjacent cells then go back on the path until an unvisited adjacent cell is found")
        Console.WriteLine("     5. The algorithm ends when there are no more unvisited cells on the grid")
        Console.WriteLine($"{Environment.NewLine}Recursive Backtracker algorithm:")
        Console.WriteLine("     1. Pick a random starting cell from the grid, make that the current cell and mark it as visited")
        Console.WriteLine("     2. While there are unvisited cells")
        Console.WriteLine("         1. If the current cell has unvisited neighbours")
        Console.WriteLine("             1. Randomly choose one of the unvisited neighbours")
        Console.WriteLine("             2. Carve a path to the unvisited neighbour from the current cell")
        Console.WriteLine("             3. The chosen neighbour now becomes the current cell")
        Console.WriteLine("             4. Record where it came from")
        Console.WriteLine("             5. Mark the current cell as visited")
        Console.WriteLine("         2. If the stack isn't empty")
        Console.WriteLine("             1. Pop a cell from the stack")
        Console.WriteLine("             2. Get the previous Cell")
    End Sub
    Sub RecrusiveBacktrackerRecursionInfo()
        Console.WriteLine("The recursive implementation of the Recursive Backtracker algortihm is very similar to the iterative version")
        Console.WriteLine($"{Environment.NewLine}Steps in generating a maze using the Recursive Backtracker Algorithm:")
        Console.WriteLine("     1. Choose a random starting cell from the grid, this becomes the current cell")
        Console.WriteLine("     2. Randomly carve a passage to an adjacent cell, but only if it hasn't already been visited")
        Console.WriteLine("     3. This cell now becomes the current cell")
        Console.WriteLine("     4. If there are no unvisited adjacent cells then go back on the path until an unvisited adjacent cell is found")
        Console.WriteLine("     5. The algorithm ends when there are no more unvisited cells on the grid")
        Console.WriteLine($"{Environment.NewLine}Recursive Backtracker Algorithm:")
        Console.WriteLine("     1. Pick a random starting cell from the grid, make that the current cell and mark it as visited")
        Console.WriteLine("     2. Call the function with the inputs being")
        Console.WriteLine("         1. The current cell")
        Console.WriteLine("         2. The boarders of the grid")
        Console.WriteLine("         3. The state of each cell on the grid (visited/unvisited)")
        Console.WriteLine("         4. The previous cell (a stack is no longer needed)")
        Console.WriteLine("     3. If there is an unvisited adjacent neighour available")
        Console.WriteLine("         1. Carve a path between the current cell and the unvisited adjacent neighbour")
        Console.WriteLine("         2. Make the previous cell the current cell")
        Console.WriteLine("         3. Recursively call the function with the current cell being the unvisited adjacent neighbour")
        Console.WriteLine("     4. If there aren't any unvisited adjacent neighbours")
        Console.WriteLine("         1. Return nothing")
        Console.WriteLine("     5. Make the previous cell the current cell")
        Console.WriteLine("     6. Recursively call the function")
    End Sub
    Sub Prims_SimplifiedINFO()
        Console.WriteLine("The simplified version of Prim's Algorithm for maze generation is basically the same as true Prims algorithm however")
        Console.WriteLine("It assumes the weight of each edge in the grid is the same and therefore chooses a random edge instead of the edge with the lowest weight")
        Console.WriteLine($"{Environment.NewLine}Steps in generating a maze using the Prims algorithm (simplified):")
        Console.WriteLine("     1. Choose a random starting cell, and put it into a set (we'll call it V)")
        Console.WriteLine("     2. Choose an edge with the smallest weight from the grid that connects a cell in V that is not in V")
        Console.WriteLine("     3. Carve a path between the cell that is in V and isn't in V")
        Console.WriteLine("     4. Add the new cell to V")
        Console.WriteLine("     5. Repeat steps 2 to 4")
        Console.WriteLine("     6. the algorithm ends when every cell is in V")
        Console.WriteLine($"{Environment.NewLine}Prim's Algorithm (simplified):")
        Console.WriteLine("     1. Initilise a frontier set")
        Console.WriteLine("     2. Initialise a visited set")
        Console.WriteLine("     3. While the frontier set is not empty")
        Console.WriteLine("         1. Add all of the unvisited adjacent cells of the current cell to the frontier set")
        Console.WriteLine("         2. Make the current cell a random cell from the frontier set")
        Console.WriteLine("         3. Create an adjacency list of the adjacent cells of the current cell that are in the visited set")
        Console.WriteLine("         4. Randomly pick a cell from this adjacency list")
        Console.WriteLine("         5. Carve a path between these two cells")
        Console.WriteLine("         6. Remove this cell from the frontier set")
        Console.WriteLine("         7. Add this cell to the visited set")
    End Sub
    Sub Prims_TrueINFO()
        Console.WriteLine("The true version of Prim's Algorithm for maze generation is basically the same as the simplified Prims algorithm however")
        Console.WriteLine("Assigns each edge a random weight between 0, 99, it then chooses the cell with the lowest weight out of the frontier set")
        Console.WriteLine($"{Environment.NewLine}Steps in generating a maze using the Prims algorithm (simplified):")
        Console.WriteLine("     1. Choose a random starting cell, and put it into a set (we'll call it V)")
        Console.WriteLine("     2. Choose an edge with the smallest weight from the grid that connects a cell in V that is not in V")
        Console.WriteLine("     3. Carve a path between the cell that is in V and isn't in V")
        Console.WriteLine("     4. Add the new cell to V")
        Console.WriteLine("     5. Repeat steps 2 to 4")
        Console.WriteLine("     6. the algorithm ends when every cell is in V")
        Console.WriteLine($"{Environment.NewLine}Prim's Algorithm (simplified):")
        Console.WriteLine("     1. Initilise a frontier set")
        Console.WriteLine("     2. Initialise a visited set")
        Console.WriteLine("     3. Initialise a dictionary of a cell and an integer")
        Console.WriteLine("     3. While the frontier set is not empty")
        Console.WriteLine("         1. Add all of the unvisited adjacent cells of the current cell to the frontier set")
        Console.WriteLine("         2. Loop through the frontier set")
        Console.WriteLine("             1. Pick the edge with the lowest weight")
        Console.WriteLine("         3. Create an adjacency list of the adjacent cells of the current cell that are in the visited set")
        Console.WriteLine("         4. Randomly pick a cell from this adjacency list")
        Console.WriteLine("         5. Carve a path between these two cells")
        Console.WriteLine("         6. Remove this cell from the frontier set")
        Console.WriteLine("         7. Add this cell to the visited set")
    End Sub
    Sub HuntAndKillInfoFirstCell()
        Console.WriteLine("Steps in generating a maze using the Hunt and Kill Algorithm:")
        Console.WriteLine("     1. Choose a random starting cell")
        Console.WriteLine("     2. Randomly carve to an unvisited adjacent neighbour, until there aren't any unvisited neighbours available")
        Console.WriteLine("     3. When there aren't any unvisited neighbours available enter hunt mode")
        Console.WriteLine("         1. Scan the grid for a cell that is adjacent to a visited cell")
        Console.WriteLine("         2. Make the first cell found the current cell")
        Console.WriteLine("         3. Stop scanning")
        Console.WriteLine("     4. Repeat steps 2 and 3 until the scaning reveals that there aren't any unvisited cells available")
        Console.WriteLine($"{Environment.NewLine}Hunt and Kill Algorithm:")
        Console.WriteLine("     1. Pick a random starting cell from the grid, make that the current cell and mark it as visited")
        Console.WriteLine("     2. While there are unvisited cells")
        Console.WriteLine("         1. If there is an unvisited adjacent cell available")
        Console.WriteLine("             1. Pick a random cell from the available adjacent cells")
        Console.WriteLine("             2. Carve a path between this cell and the current cell")
        Console.WriteLine("             3. Make the chosen adjacent cell the current cell")
        Console.WriteLine("             4. Mark the current cell as visited")
        Console.WriteLine("         2. Else")
        Console.WriteLine("             1. Scan the grid (top to bottom, left to right)")
        Console.WriteLine("             2. If there is a cell that is adjacent to the visited cells")
        Console.WriteLine("                 1. Make it the current cell")
        Console.WriteLine("                 2. Create an adjacency list for the current cell")
        Console.WriteLine("                 3. Pick a random visited adjacent cell")
        Console.WriteLine("                 4. Carve a path between the current cell and chosen adjacent cell")
        Console.WriteLine("                 6. Mark the current cell as visited")
        Console.WriteLine("             3. Else")
        Console.WriteLine("                 The maze is finished being generated")
    End Sub
    Sub RandomisedBreadthFirstSearch()
        Console.WriteLine("This just uses breadth first search but instead of using a queue to store adjacent cells")
        Console.WriteLine("It uses a list and instead of dequeueing the cells added it selected a random one")
        Console.WriteLine()
        Console.WriteLine("Steps in generating a maze using Randomised Breadth-First Search:")
        Console.WriteLine("     1. Initialise a random cell and add it to the list")
        Console.WriteLine("     2. Set this cell to be visited")
        Console.WriteLine("     2. While the list is not empty")
        Console.WriteLine("         1. Set cell 'v' to be a random cell from the list")
        Console.WriteLine("         2. Add all neighbours of v to the list if they are not visited")
        Console.WriteLine("         3. Set each neighbour to be visited if they aren't already visited")
    End Sub
    Sub HuntAndKillInfoRandomCell()
        Console.WriteLine("The random version  of this algorithm changed step 3")
        Console.WriteLine("Instead of just selected the first cell found to be new cell and then stop scanning")
        Console.WriteLine("Continue to scan the entire grid adding all adjacent cells to a list")
        Console.WriteLine("Then randomly pick one of these cells")
        Console.WriteLine()
        Console.WriteLine("Steps in generating a maze using the Hunt and Kill Algorithm:")
        Console.WriteLine("     1. Choose a random starting cell")
        Console.WriteLine("     2. Randomly carve to an unvisited adjacent neighbour, until there aren't any unvisited neighbours available")
        Console.WriteLine("     3. When there aren't any unvisited neighbours available enter hunt mode")
        Console.WriteLine("         1. Scan the grid for a cell that is adjacent to a visited cell")
        Console.WriteLine("         2. Add adjacent cells to a list")
        Console.WriteLine("         3. if the entire grid has been scanned")
        Console.WriteLine("             4. Randomly pick a cell from the adjacent cell list")
        Console.WriteLine("     4. Repeat steps 2 and 3 until the scaning reveals that there aren't any unvisited cells available")
        Console.WriteLine($"{Environment.NewLine}Hunt and Kill Algorithm:")
        Console.WriteLine("     1. Pick a random starting cell from the grid, make that the current cell and mark it as visited")
        Console.WriteLine("     2. While there are unvisited cells")
        Console.WriteLine("         1. If there is an unvisited adjacent cell available")
        Console.WriteLine("             1. Pick a random cell from the available adjacent cells")
        Console.WriteLine("             2. Carve a path between this cell and the current cell")
        Console.WriteLine("             3. Make the chosen adjacent cell the current cell")
        Console.WriteLine("             4. Mark the current cell as visited")
        Console.WriteLine("         2. Else")
        Console.WriteLine("             1. Scan the grid (top to bottom, left to right)")
        Console.WriteLine("             2. If there is a cell that is adjacent to the visited cells")
        Console.WriteLine("                 1. Make it the current cell")
        Console.WriteLine("                 2. Create an adjacency list for the current cell")
        Console.WriteLine("                 3. Pick a random visited adjacent cell")
        Console.WriteLine("                 4. Carve a path between the current cell and chosen adjacent cell")
        Console.WriteLine("                 6. Mark the current cell as visited")
        Console.WriteLine("             3. Else")
        Console.WriteLine("                 The maze is finished being generated")
    End Sub
    Sub AldousBroderInfo()
        Console.WriteLine("Steps in generating a maze using the Aldous-Broder Algorithm:")
        Console.WriteLine("     1. Choose a random starting cell")
        Console.WriteLine("     2. Randomly pick an adjacent cell")
        Console.WriteLine("     3. If it is unvisited then carve a path")
        Console.WriteLine("     4. When there are no unvisited cells the maze is finished being generated")
        Console.WriteLine($"{Environment.NewLine}Aldous-Broder Algorithm:")
        Console.WriteLine("     1. Pick a random starting cell from the grid, make that the current cell and mark it as visited")
        Console.WriteLine("     2. While there are unvisited cells")
        Console.WriteLine("         1. Pick a random adjacent neighbour of the current cell")
        Console.WriteLine("         2. If the chosen neighbour is unvisited")
        Console.WriteLine("             1. Carve a path to the chosen neighbour")
        Console.WriteLine("         3. Make the chosen neighbour the current cell")
    End Sub
    Sub GrowingTreeInfo()
        Console.WriteLine("Steps in generating a maze using the Growing Tree Algorithm:")
        Console.WriteLine("     1. Let C be a list of cells")
        Console.WriteLine("     2. Add a random starting cell to C")
        Console.WriteLine("     3. Choose a cell from C and carve a path tp any unvisited neighbours")
        Console.WriteLine("     4. Add the chosen neighbour to C, if there are no unvisited neighbours remove the cell from C")
        Console.WriteLine("     5. Repeat steps 3 and 4 until C is empty")
        Console.WriteLine($"{Environment.NewLine}Growing Tree Algorithm:")
        Console.WriteLine("     1. Pick a random starting cell from the grid, make that the current cell and mark it as visited")
        Console.WriteLine("     2. While there are unvisited cells")
        Console.WriteLine("         1. Pick a cell from C according to the cell selection method that has been chosen")
        Console.WriteLine("         2. Make the chosen cell the current cell")
        Console.WriteLine("         3. Create an adjacency list of the current cell")
        Console.WriteLine("         4. Carve a path from a random cell in the adjacency list to the current cell")
        Console.WriteLine("         5. Mark the current cell as visited")
        Console.WriteLine("         6. Remove the current cell from C")
    End Sub
    Sub SidewinderInfo()
        Console.WriteLine("Steps in generating a maze using the Sidewinder Algorithm:")
        Console.WriteLine("     1. Work across the grid by rows, adding the current cell to the run set")
        Console.WriteLine("     2. Choose whether to carve east or not")
        Console.WriteLine("     3. If you dont carve east then pick a random cell from the run set and carve south")
        Console.WriteLine("     4. The algorithm is done when all of the cells have been visited")
        Console.WriteLine($"{Environment.NewLine}Sidewinder Algorithm:")
        Console.WriteLine("     1. Work through the grid a row at a time, starting with a cell at 0,0")
        Console.WriteLine("     2. Initialise a run set which keeps track of the cells in it")
        Console.WriteLine("     3. Add the current cell to the run set")
        Console.WriteLine("     4. For the current cell in the row randomly decide whether or not to carve a wall east or not")
        Console.WriteLine("     5. If a passage was carved east")
        Console.WriteLine("         1. Make the new cell the current cell and repeat step 3 and 4")
        Console.WriteLine("     6. If a passage wasn't carved east ")
        Console.WriteLine("         1. Choose a random cell from the run set and carve south")
        Console.WriteLine("         2. Empty the run set")
        Console.WriteLine("         3. Repeat steps 2-6")
        Console.WriteLine("     7. Continue until all rows have been processed")
        Console.WriteLine()
    End Sub
    Sub BinaryTreeInfo()
        Console.WriteLine("Steps in generating a maze using the Binary Tree Algorithm:")
        Console.WriteLine("     1. Work acrowss the grid by rows or columns")
        Console.WriteLine("     2. Randomly choose to carve a passage either north or west")
        Console.WriteLine("     3. The algorithm is done once all of the cells have been visited")
        Console.WriteLine($"{Environment.NewLine}Binary Tree Algorithm (for maze geneation):")
        Console.WriteLine("     1. Loop through all cells on the grid")
        Console.WriteLine("     2. For each cell on the grid")
        Console.WriteLine("         1. Randomly carve west or north")
        Console.WriteLine("     3. The Algorithm is done once all of the cells on the grid have been visited")
    End Sub
    Sub WilsonsInfo()
        Console.WriteLine("Wilson's algorithm can be generated in different ways depending on how the cell that isn't in the UST is chosen")
        Console.WriteLine()
        Console.WriteLine("Steps in generating a maze using Wilson's Algorithm:")
        Console.WriteLine("     1. Choose a random cell and add it to the UST")
        Console.WriteLine("     2. Select any cell that is not already in the UST an perform a random walk until you encounter a cell that is in the UST")
        Console.WriteLine("     3. Add the cell to the UST")
        Console.WriteLine("     4. Repeat steps 2 and 3 until all cells have been added to the UST")
        Console.WriteLine($"{Environment.NewLine}Wilson's Algorithm (for maze geneation):")
        Console.WriteLine("     1. Pick a random cell on the grid")
        Console.WriteLine("     2. Add it to the Uniform Spanning Tree")
        Console.WriteLine("     3. Pick a random cell on the grid that isn't in the Uniform Spanning Tree")
        Console.WriteLine("     4. Perform a random walk from this cell keeping track of where it came from")
        Console.WriteLine("     5. If the cell is in the Uniform Spanning Tree")
        Console.WriteLine("         1. Trace the path from the start of the random walk to the Uniform Spanning Tree")
        Console.WriteLine("         2. Add the path to the Uniform Spanning Tree")
        Console.WriteLine("         3. Pick a random cell that isn't in the Uniform Spanning Tree")
        Console.WriteLine("         4. Repeat steps 4 and 5")
        Console.WriteLine("     6. The Algorithm is complete when there are no unvisited cells on the grid")
    End Sub
    Sub EllersInfo()
        Console.WriteLine("Ellers algorithm requires the most overhead out of all of the algorithms")
        Console.WriteLine()
        Console.WriteLine("Steps in generating a maze using Eller's Algorithm:")
        Console.WriteLine("     1. Initilise the cells of the first row with each of them being assigned their own set")
        Console.WriteLine("     2. Now randomly join adjacent cells, but only if they are not in the same set")
        Console.WriteLine("        When joining adjacent cells, merge the cells of both sets into a single set")
        Console.WriteLine("     3. For each set randomly carve a connection downwards to the next row")
        Console.WriteLine("        Each remaining set must have at least one verticle connection")
        Console.WriteLine("        The cells in the next row thus connected must share the set of the cell above them")
        Console.WriteLine("     4. Go though the next row putting any remaining cells into their own sets")
        Console.WriteLine("     5. Continue until the last row is reached")
        Console.WriteLine("     6. For the last row join adjacent cells that do not share the same set")
        Console.WriteLine("        As this is the last row connections downwards don't need to be carved ")
    End Sub
    Sub KruskalsInfoSimplified()
        Console.WriteLine("Steps in generating a maze using Kruskal's Algorithm:")
        Console.WriteLine("     1. Put all edges into a list")
        Console.WriteLine("     2. Assign each cell a unique set")
        Console.WriteLine("     3. Select an edge at random")
        Console.WriteLine("     4. If the edge connects two disjointed trees")
        Console.WriteLine("         1. Join the trees and combine the sets")
        Console.WriteLine("     5. If the two vertices connecting to that edge are of the same set remove the edge")
        Console.WriteLine("     6. Repeat until no edges remaing")
    End Sub
    Sub KruskalsInfoTrue()
        Console.WriteLine("The true version of Kruskal's changes the second step from the simplified version")
        Console.WriteLine("Instead of a random edge being selected the edge with the lowest weight is selected")
        Console.WriteLine()
        Console.WriteLine("Steps in generating a maze using Kruskal's Algorithm:")
        Console.WriteLine("     1. Put all edges into their own set")
        Console.WriteLine("     2. Assign each cell a unique set")
        Console.WriteLine("     3. Select the edge with the lowest weight")
        Console.WriteLine("     4. If the edge connects two disjointed trees")
        Console.WriteLine("         1. Join the trees and combine the sets")
        Console.WriteLine("     5. If the two vertices connecting to that edge are of the same set remove the edge")
        Console.WriteLine("     6. Repeat until no edges remaing")
    End Sub
    Sub HoustonsInfo()
        Console.WriteLine("Houston' algorithm combines Aldous-Broder and Wilson's algorithm")
        Console.WriteLine("Aldous-Broder is used until some minimum number of cells have been visited and then Wilson's Algorithms is used")
        Console.WriteLine("This combination gives you better performance than either algorithm itself")
        Console.WriteLine("However it is uncertain that it gives you a uniform spanning tree")
        Console.WriteLine()
        Console.WriteLine("Steps in generating a maze using Houstons's Algorithm:")
        Console.WriteLine("     1. If some number of minimum cells have been visited")
        Console.WriteLine("         1. Select any cell that is not already in the UST an perform a random walk until you encounter a cell that is in the UST")
        Console.WriteLine("         2. Add the cell to the UST")
        Console.WriteLine("         3. Repeat steps 2 and 3 until all cells have been added to the UST")
        Console.WriteLine("     2. Else")
        Console.WriteLine("         1. Choose a random starting cell")
        Console.WriteLine("         2. Randomly pick an adjacent cell")
        Console.WriteLine("         3. If it is unvisited then carve a path")
        Console.WriteLine("         4. When there are no unvisited cells the maze is finished being generated")
    End Sub
    Sub SpiralBacktrackerInfo()
        Console.WriteLine("This algorithm is very similar to the recursive backtracker algorithm")
        Console.WriteLine("But instead of picking a random neighbour it goes in a certain direction for a defined number of steps")
        Console.WriteLine()
        Console.WriteLine("Steps in generating a maze using Spiral Backtracker Algorithm:")
        Console.WriteLine("     1. Choose a random starting cell from the grid, this becomes the current cell")
        Console.WriteLine("     2. Carve a passage in a defined direction for a defined number of steps to an adjacent cell, but only if it hasn't already been visited")
        Console.WriteLine("     3. This cell now becomes the current cell")
        Console.WriteLine("     4. If there are no unvisited adjacent cells then go back on the path until an unvisited adjacent cell is found")
    End Sub
    Sub CustomAlgorithmInfo()
        Console.WriteLine("This was an algorithm that i came up with when attempting to code the Growing Tree Algorithm")
        Console.WriteLine()
        Console.WriteLine("Steps in generating a maze using the Spiral Backtracker Algorithm:")
        Console.WriteLine("     1. Initialise a starting cell, mark it as visited")
        Console.WriteLine("     2. Initialise and frontierSet and a recentFrontierSet")
        Console.WriteLine("     3. Add the current cells neighbours to the frontierSet and recentFrontierSet")
        Console.WriteLine("     4. If the recentFrontierSet is not empty")
        Console.WriteLine("         1. Randomly pick a neighbour from this set")
        Console.WriteLine("         2. Carve a path to this cell")
        Console.WriteLine("     5. Else")
        Console.WriteLine("         1. If the frontierSet is not empty")
        Console.WriteLine("             1. Randomly pick a neighbour from this set")
        Console.WriteLine("             2. Carve a path to this cell")
        Console.WriteLine("         2. The maze is finished")
    End Sub
    Sub BoruvkasAlgorithmInfo()
        Console.WriteLine("Steps in generating a maze using Boruvkas Algorithm:")
        Console.WriteLine("     1. Assign each cell a set number")
        Console.WriteLine("     2. Assign each edge a number")
        Console.WriteLine("     3. Loop through each cell until all cells are in the same set")
        Console.WriteLine("         1. Find the adjacent edge with the lowest weight")
        Console.WriteLine("         2. Carve to the cell connecting to this edge")
        Console.WriteLine("         3. Remove the edge")

        Console.WriteLine($"{Environment.NewLine}Boruvkas Algorithm:")
        Console.WriteLine("     1. Assign each cell in the grid a set number")
        Console.WriteLine("     2. Assign each edge a weight")
        Console.WriteLine("     3. While there are different sets")
        Console.WriteLine("         1. For each unvisited cell")
        Console.WriteLine("             1. Select the lowest weight edge")
        Console.WriteLine("             2. Carve to the cell connected to this edge")
        Console.WriteLine("             3. Combine both of the sets")
        Console.WriteLine("             4. Store this edge")
        Console.WriteLine("         2. Remove the edges that were used")
    End Sub
    Sub ReverseDeleteAlgorithmInfo()
        Console.WriteLine("Steps in generating a maze using the Reverse-delete Algorithm:")
        Console.WriteLine("     1. Create a list of all the edges sorted in descending order")
        Console.WriteLine("     2. For every edge")
        Console.WriteLine("         1. Delete the first edge")
        Console.WriteLine("         2. Check to see if the two node that are connected by the edge are still both in the tree")
        Console.WriteLine("         3. If the two vertices aren't connected then reinsert the edge")
        Console.WriteLine($"{Environment.NewLine}Reverse-delete Algorithm:")
        Console.WriteLine("     1. Assign each edge a weight")
        Console.WriteLine("     2. Add each weight to a list")
        Console.WriteLine("     3. While there is something in this list")
        Console.WriteLine("         1. Pick the edge with the lowest weight")
        Console.WriteLine("         2. Find the two vertices that connect to this edge")
        Console.WriteLine("         3. Check to see if the two edges are still in the same tree using a graph traversal algorithm")
        Console.WriteLine("         4. If the two vertices can't be reached")
        Console.WriteLine("             1. Reinsert the edge")
        Console.WriteLine("         5. If they can be reached")
        Console.WriteLine("             1. Remove the edge from the list")
    End Sub



End Module
